// const {get} = require('https');
// const {chain} = require('stream-chain');
// const {parser} = require('stream-json');
// const {pick} = require('stream-json/filters/Pick');
// const {streamArray} = require('stream-json/streamers/StreamArray');
// const {pointToTile} = require('@mapbox/tilebelt');
// const {find} = require('geo-tz');
// const {utilWriteFile} = require('./utils');

// module.exports = function() {
//   const zooms = [...Array(5).keys()].map(i => 16 + i),
//         tiles = {},
//         bouyHistory = {}

//   return new Promise(resolve => {
//     get('https://www.ndbc.noaa.gov/ndbcmapstations.json', (res) => {
//       const pipeline = chain([
//         res,
//         parser(),
//         pick({filter: 'station'}),
//         streamArray()
//       ])

//       pipeline.on('data', (bouy) => {
//         if (!bouyHistory[bouy.value.id]) {
//           bouyHistory[bouy.value.id] = {
//             timezone: find(bouy.value.lat, bouy.value.lon).join(','),
//             filenames: {}
//           }
//         }
//         zooms.forEach(zoom => {
//           const tileKey = pointToTile(bouy.value.lon, bouy.value.lat, zoom).reverse().join('/')
//           if (!tiles.hasOwnProperty(tileKey)) {
//             tiles[tileKey] = {
//               "type": "FeatureCollection",
//               "features": []
//             }
//           }
//           tiles[tileKey].features.push({
//             "type": "Feature",
//             "properties": {
//               id: bouy.value.id,
//               name: bouy.value.name,
//             },
//             "geometry": {
//               "type": "Point",
//               "coordinates": [bouy.value.lon, bouy.value.lat]
//             }
//           });
//         })
//       })

//       pipeline.on('end', () => {
//         Object.keys(tiles).forEach(tileKey =>
//           utilWriteFile(`tiles/${tileKey}.geojson`, JSON.stringify(tiles[tileKey])))

//         resolve(bouyHistory);
//       })
//     })
//   })
// }

use std::collections::HashMap;
use serde_json::Value;

// ref... https://github.com/mapbox/tilebelt

// /**
//  * Get the tile for a point at a specified zoom level
//  *
//  * @name pointToTile
//  * @param {number} lon
//  * @param {number} lat
//  * @param {number} z
//  * @returns {Array<number>} tile
//  * @example
//  * var tile = pointToTile(1, 1, 20)
//  * //=tile
//  */
// function pointToTile(lon, lat, z) {
//     var tile = pointToTileFraction(lon, lat, z);
//     tile[0] = Math.floor(tile[0]);
//     tile[1] = Math.floor(tile[1]);
//     return tile;
// }

// /**
//  * Get the precise fractional tile location for a point at a zoom level
//  *
//  * @name pointToTileFraction
//  * @param {number} lon
//  * @param {number} lat
//  * @param {number} z
//  * @returns {Array<number>} tile fraction
//  * var tile = pointToTileFraction(30.5, 50.5, 15)
//  * //=tile
//  */
// function pointToTileFraction(lon, lat, z) {
// d2r = Math.PI / 180,
//

const D2R: f64 = std::f64::consts::PI / 180.0;
fn point_to_tile_fraction(lon: f64, lat: f64, z: u32) {
    let sin: f64 = (lat * D2R).sin();
    let z2: f64 = std::f64::from(2usize.pow(z));
    let x: f64 = std::f64::from(z2 * (lon / 360.0 + 0.5);
}
//     var sin = Math.sin(lat * d2r),
//         z2 = Math.pow(2, z),
//         x = z2 * (lon / 360 + 0.5),
//         y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

//     // Wrap Tile X
//     x = x % z2;
//     if (x < 0) x = x + z2;
//     return [x, y, z];
// }

struct GeoJsonPoint {
    r#type: String,
    coordinates: [f32; 2]
}

impl GeoJsonPoint {
    pub fn new(lon: f32, lat: f32) -> Self {
        Self { r#type: String::from("Point"), coordinates: [lon,lat] }
    }
}

struct GeoJsonPointFeature<'a> {
    r#type: String,
    properties: &'a HashMap<String,String>,
    geometry: &'a GeoJsonPoint
}

impl<'a> GeoJsonPointFeature<'a> {
    pub fn new(properties: &'a HashMap<String, String>, geometry: &'a GeoJsonPoint) -> Self {
        Self {
            r#type: String::from("Feature"),
            properties: properties,
            geometry: geometry
        }
    }
}

struct BouyHistEntry {
    timezone: String,
    filenames: HashMap<String, bool>
}

impl BouyHistEntry {
    pub fn new(timezone: String) -> Self {
        Self {
            timezone: timezone,
            filenames: HashMap::new()
        }
    }
}

fn main() {
    let mut tiles: HashMap<String, GeoJsonPointFeature> = HashMap::new();
    let mut bouy_history: HashMap<String,BouyHistEntry> = HashMap::new();
    let client_result = reqwest::blocking::Client::builder().build();
    match client_result {
        Ok(client) => {
            match client.get("https://www.ndbc.noaa.gov/ndbcmapstations.json").send() {
                Ok(resp) => {
                    let bouys_json: Value = serde_json::from_str(resp.text().unwrap().as_str()).unwrap();
                    for station in bouys_json["stations"].as_array().unwrap() {
                        let String bouy_id = station["id"].as_string().unwrap();
                        if !bouy_history.contains_key(bouy_id) {
                            // todo: use zone detect binding for timezone lookup!
                            bouy_history.insert(bouy_id, BouyHistEntry::new("foo"));
                        }
                    }
                    for zoom in 16..21 {
                        //           const tileKey = pointToTile(bouy.value.lon, bouy.value.lat, zoom).reverse().join('/')

                    }

                }
                Err(err) => { println!("Request Error: {}", err); }
            }
            //
            // ignore chars until i get to stations.
            //
        },
        Err(err) => {
            println!("Error: {}", err);
        }
    }
}
